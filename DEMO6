	TITLE 'EXAMPLE OF A QUIKSORT ALGORITHM'
********************************
*
* THIS PROGRAM BUILDS AND SORTS 
* A TABLE USING THE QUIKSORT 
* ALGORITHM.
*
********************************
	SPACE
MAIN	XSAVE
*
*** BUILD A TABLE OF INTEGERS
*
	LA	R1,=A(TABLE,NUMENT)
	L	R15,=V(READTAB)
	BALR	R14,R15
*
*** PRINT THE TABLE
*
	XPRNT =C'1                       *** THE UNSORTED TABLE ***'
	LA	R1,=A(TABLE,NUMENT)
	L	R15,=V(PRNTTAB)
	BALR	R14,R15
*
*** SORT THE TABLE
*
	LA	R1,=A(TABLE,NUMENT)
	L	R15,=V(SORTTAB)
	BALR	R14,R15
*
*** PRINT THE SORTED TABLE
*
	XPRNT	=C'1                        *** THE SORTED TABLE ***'
	LA	R1,=A(TABLE,NUMENT)
	L	R15,=V(PRNTTAB)
	BALR	R14,R15
*
*** EXIT THE PROGRAM
*
	XRETURN
*
	LTORG
*
SAVEAREA	DS	18F
TABLE	DS	50F
NUMENT	DS	F
	TITLE	'READ A TABLE OF NUMBERS'
*********************************************************************
*
* THIS ROUTINE BUILDS A TABLE OF INTEGERS FROM AN INPUT STREAM OF
* NUMBERS.
*
*********************************************************************
	SPACE
READTAB	XSAVE
*
	LM	R2,R3,0(R1)	GET THE PARAMETERS
*			R2 <--- @ TABLE
*			R3 <--- @ NUMBER OF ENTRIES
*
*** POINT TO THE NEXT (FIRST) ENTRY IN THE TABLE
*
	LR	R4,R2	R4 POINTS AN THE NEXT ENTRY
*
*** READ THE FIRST CARD
*
	XREAD	CARD,80
*
*** CHECK FOR END-OF-FILE
*
TESTEOF	BC	B'0100',READEXIT
*
*** PUT THE NUMBER IN THE TABLE
*
	XDECI	R0,CARD
	ST	R0,0(R4)
	LA	R4,4(R4)
*
*** READ THE NEXT NUMBER
*
	XREAD	CARD,80
	B	TESTEOF
*
*** SAVE THE NUMBER OF TABLE ENTRIES AND RETURN
*
READEXIT	SR	R4,R2
	SRA	R4,2
	ST	R4,0(R3)	RETURN ANSWER TO CALLER
*
	XRETURN
*
	LTORG
*
CARD	DS	CL80	INPUT AREA FOR CARDS
	TITLE	'PRINT A TABLE OF NUMBERS'
*********************************************************************
*
* THIS ROUTINE PRINTS A TABLE OF NUMBERS - FIVE NUMBERS TO THE LINE
*
*********************************************************************
	SPACE
PRNTTAB	XSAVE
*
*** GET THE PARAMETERS
*
	LM	R2,R3,0(R1)	GET THE PARAMETERS
*			R2 <--- @ OF TABLE TO PRINT
*			R3 <--- @ OF NUMBER OF ENTRIES 
	L	R4,0(R3)	R4 <--- NUMBER OF ENTRIES
*
*** TEST FOR THE END OF THE TABLE
*
PRNTLN	LTR	R4,R4
	BNP	PRNTEXIT	EXIT AT END OF TABLE
*
	SR	R11,R11	INDEX TO THE PLINE
	LA	R5,5	PRINT FIVE ENTRIES
*
*** TEST FOR A FULL PRINTLINE
*
TESTFULL	LTR	R5,R5
	BZ	PRNT1LN
	LTR	R4,R4
	BNP	PRNT1LN
*
*** PUT ONE ENTRY IN THE PRINTLINE
*
	L	R0,0(R2)	GET ONE ENTRY
	XDECO	R0,PLINE(R11)	PUT IT IN THE LINE
*
	LA	R11,14(R11)	BUMP PLINE ENTRY
	S	R5,=F'1'
	S	R4,=F'1'
	LA	R2,4(R2)	BUMP TABLE POINTER
         B	TESTFULL
*
* PRINT ONE LINE
*
PRNT1LN	XPRNT	PLINE-1,70
	MVI	PLINE-1,C' '
	MVC	PLINE+1(70),PLINE
	B	PRNTLN
*
PRNTEXIT	MVI	PLINE-1,C'0'
	XRETURN
*
	LTORG
*
	DC	C'0'	CARRIAGE CONTROL
PLINE	DC	CL70' '
	TITLE 'QUIKSORT A TABLE OF INTEGERS'
*********************************************************************
*
* THIS PROGRAM QUIKSORTS A TABLE OF INTEGERS USING A STACK 
* ALGORITHM
*
*********************************************************************
	SPACE
SORTTAB	XSAVE
*
	LM	R2,R3,0(R1)	GET THE PARAMETERS
*			R2 <--- @ OF TABLE TO SORT
*			R3 <--- @ OF NUMBER OF ENTRIES
*
*** PUSH THE TABLE ON THE STACK
*
	L	R4,AVAIL	GET A NODE FROM AVAIL STACK
	MVC	AVAIL,0(R4)
*
	ST	R2,4(R4)	FORMAT THE NODE
	MVC	8(4,R4),0(R3)
*
	MVC	0(4,R4),TABS	PUT IT ON THE STACK
	ST	R4,TABS
*
*** WHILE THE STACK OF TABLES TO SORT IS NOT EMPTY
*
DO1	CLC	TABS,=A(0)
	BE	ENDDO1
*
*** POP THE STACK OF TABLES TO SORT
*
	L	R4,TABS	GET THE NODE
	MVC	TABS,0(R4)
*
	L	R5,4(R4)	R5 <--- @ OF TABLE TO SORT
	L	R6,8(R4)	R6 <--- NUMBER OF ENTRIES
*
	MVC	0(4,R4),AVAIL	PUT NODE BACK ON AVAIL STACK
	ST	R4,AVAIL
*
	BCTR	R6,0	R6 <--- @ OF LAST ENTRY
	SLA	R6,2
	LA	R6,0(R5,R6)
*
*** NOW PARTITION THE TABLE INTO TWO SMALLER TABLES
*
	LR	R7,R5	GET SET UP
	LR	R8,R6
*
* R7 SCANS FROM THE TOP OF THE TABLE . . . R8 FROM THE BOTTOM
*
* PICK UP THE MEDIAN ESTIMATE FROM THE TOP
*
	L	R9,0(R7)	R9 <--- MEDIAN ESTIMATE
*
*** WHILE THE BOTTOM SCAN HAS NOT CROSSED THE TOP SCAN
*
DO2	CR	R7,R8
	BNL	ENDDO2
*
*** SCAN FROM THE BOTTOM FOR A NUMBER SMALLER THAN THE ESTIMATE
*
DO3	CR	R7,R8
	BNL	ENDDO3
	C	R9,0(R8)
	BH	ENDDO3
*
	S	R8,=F'4'	DECREMENT THE BOTTOM SCAN
	B	DO3
ENDDO3	DS	0H
*
*** PUT THE NUMBER AT THE BOTTOM SCAN IN THE HOLE
*
IF1	CR	R7,R8
	BNL	ENDIF1
	MVC	0(4,R7),0(R8)
	LA	R7,4(R7)
ENDIF1	DS	0H
*
* SCAN FROM TOP FOR A NUMBER LARGER THAN THE ESTIMATE
*
DO4	CR	R7,R8
	BNL	ENDDO4
	C	R9,0(R7)
	BL	ENDDO4
*
	LA	R7,4(R7)	INCREMENT THE TOP SCAN
	B	DO4
ENDDO4	DS	0H
*
*** PUT THE NUMBER AT THE TOP SCAN IN THE HOLE
*
IF2	CR	R7,R8
	BNL	ENDIF2
	MVC	0(4,R8),0(R7)
	S	R8,=F'4'
ENDIF2	DS	0H
*
	B	DO2
ENDDO2	DS	0H
*
* PUT THE MEDIAN ESTIMATE BACK IN THE TABLE AT THE HOLE
*
	ST	R9,0(R7)
*
*** STACK THE TWO TABLES
*
	LR	R8,R7
*
*** COMPUTE THE NUMBER OF ENTRIES IN THE TOP TABLE AND PUSH IT
*   ON THE STACK IF ITS NOT EMPTY
*
IF3	SR	R8,R5
	SRA	R8,2
	BNP	ENDIF3
*
	L	R10,AVAIL	GET NODE FROM AVAIL STACK
	MVC	AVAIL,0(R10)
*
	ST	R5,4(R10)	FORMAT IT
	ST	R8,8(R10)
*
	MVC	0(4,R10),TABS	PUSH IT ON THE STACK
	ST	R10,TABS	
ENDIF3	DS	0H
*
*** COMPUTE THE NUMBER OF ENTRIES IN THE BOTTOM TABLE AND STACK IT
*   IF ITS NOT EMPTY
*
IF4	SR	R6,R7
	SRA	R6,2
	BNP	ENDIF4
*	
	L	R10,AVAIL	GET NODE FROM AVAIL STACK
	MVC	AVAIL,0(R10)
*
	LA	R7,4(R7)	FORMAT IT
	ST	R7,4(R10)
	ST	R6,8(R10)
*
	MVC	0(4,R10),TABS	PUSH IT ON THE STACK
	ST	R10,TABS
ENDIF4	DS	0H
*
	B	DO1
ENDDO1	DS	0H
*
	XRETURN
*
	LTORG
*
TABS     DC	A(0)	STACK OF TABLES TO SORT
AVAIL	DC	A(STACK)	STACK OF AVAIABLE STORAGE
STACK	DC	20A(*+12,0,0)
	DC	A(0,0,0)
*
R0	EQU	0
R1	EQU	1
R2	EQU	2
R3	EQU	3
R4	EQU	4
R5	EQU	5
R6	EQU	6
R7	EQU	7
R8	EQU	8
R9	EQU	9
R10	EQU	10
R11	EQU	11
R12	EQU	12
R13	EQU	13
R14	EQU	14
R15	EQU	15
	END
$ENTRY	
10
5
8
11
9
3
2
7
12
1
13
15
